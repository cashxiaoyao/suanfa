<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>
</html>
<script>
    /*
    在js中二叉树使用对象来定义，结构分为三块：
    1.数据域
    2.左侧子结点（左子树根结点）的引用
    3.右侧子结点（右子树根结点）的引用


    在定义二叉树构造函数时，我们需要把左侧子结点和右侧子结点都预置为空：
    */
    function TreeNode(val){
        this.value = val
        this.left = this.right = null
    }

    
    //所谓的“先序”、“中序”和“后序”，“先”、“中”、“后”其实就是指根结点的遍历时机。
    const root = {
        val:'A',
        left:{
            val:'B',
            left:{
                val:'D'
            },
            right:{
                val:"E"
            }
        },
        right:{
            val:'C',
            right:{
                val:'F'
            }
        }
    }
// 二叉树的先序遍历  -----  根结点->左子树->右子树
    //所有遍历函数的入参都是树的根结点对象
  function preorder(root) {
        if(!root) {
            return false
        }
        
        console.log(root.val)

        // 递归遍历左子树
        preorder(root.left)
        // 递归遍历右子树
        preorder(root.right)
  }
  preorder(root)

console.log('**********************************************分界线************************************************')

  // 二叉树的中序遍历 ------ 左子树->根结点->右子树
  function inorder(root) {
      if(!root) return

    //   优先遍历左子树，先递归左子树
    inorder(root.left)

    // 打印当前遍历的值，相当如当前处理数据的逻辑
    console.log(root.val)

    // 在遍历右子树
    inorder(root.right)

  }
  inorder(root)

  console.log('**********************************************分界线************************************************')

  //二叉树的后序遍历 ----- 左子树->右子树->根结点
  function postorder(root) {
    if(!root) return

    postorder(root.left)

    postorder(root.right)

    console.log(root.val)

  }
  postorder(root)
</script>